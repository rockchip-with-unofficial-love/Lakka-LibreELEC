From cf8ec7e28b6611d92cd2f45d2b638c531b2981c7 Mon Sep 17 00:00:00 2001
From: sarbes <sarbes@kodi.tv>
Date: Sun, 12 Mar 2023 15:49:03 +0100
Subject: [PATCH 1/4] Renaming of the texture format A8 to R8

---
 xbmc/addons/ImageDecoder.cpp | 2 +-
 xbmc/guilib/GUIFontTTFDX.cpp | 2 +-
 xbmc/guilib/GUIFontTTFGL.cpp | 2 +-
 xbmc/guilib/TextureDX.cpp    | 2 +-
 xbmc/guilib/TextureFormats.h | 4 +++-
 5 files changed, 7 insertions(+), 5 deletions(-)

diff --git a/xbmc/addons/ImageDecoder.cpp b/xbmc/addons/ImageDecoder.cpp
index 6a7d52d7b1b6f..c3660ac4fe2ab 100644
--- a/xbmc/addons/ImageDecoder.cpp
+++ b/xbmc/addons/ImageDecoder.cpp
@@ -19,7 +19,7 @@ namespace
 
 constexpr std::array<std::tuple<unsigned int, ADDON_IMG_FMT, size_t>, 4> KodiToAddonFormat = {
     {{XB_FMT_A8R8G8B8, ADDON_IMG_FMT_A8R8G8B8, sizeof(uint8_t) * 4},
-     {XB_FMT_A8, ADDON_IMG_FMT_A8, sizeof(uint8_t) * 1},
+     {XB_FMT_R8, ADDON_IMG_FMT_A8, sizeof(uint8_t) * 1},
      {XB_FMT_RGBA8, ADDON_IMG_FMT_RGBA8, sizeof(uint8_t) * 4},
      {XB_FMT_RGB8, ADDON_IMG_FMT_RGB8, sizeof(uint8_t) * 3}}};
 
diff --git a/xbmc/guilib/GUIFontTTFDX.cpp b/xbmc/guilib/GUIFontTTFDX.cpp
index 0f4a6b0282af0..e1b5ba8cf1a22 100644
--- a/xbmc/guilib/GUIFontTTFDX.cpp
+++ b/xbmc/guilib/GUIFontTTFDX.cpp
@@ -239,7 +239,7 @@ std::unique_ptr<CTexture> CGUIFontTTFDX::ReallocTexture(unsigned int& newHeight)
   m_dynamicCache.Flush();
 
   std::unique_ptr<CDXTexture> pNewTexture =
-      std::make_unique<CDXTexture>(m_textureWidth, newHeight, XB_FMT_A8);
+      std::make_unique<CDXTexture>(m_textureWidth, newHeight, XB_FMT_R8);
   std::unique_ptr<CD3DTexture> newSpeedupTexture = std::make_unique<CD3DTexture>();
   if (!newSpeedupTexture->Create(m_textureWidth, newHeight, 1, D3D11_USAGE_DEFAULT,
                                  DXGI_FORMAT_R8_UNORM))
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index 12889c9b1dad1..76029bb8af052 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -292,7 +292,7 @@ std::unique_ptr<CTexture> CGUIFontTTFGL::ReallocTexture(unsigned int& newHeight)
   newHeight = CTexture::PadPow2(newHeight);
 
   std::unique_ptr<CTexture> newTexture =
-      CTexture::CreateTexture(m_textureWidth, newHeight, XB_FMT_A8);
+      CTexture::CreateTexture(m_textureWidth, newHeight, XB_FMT_R8);
 
   if (!newTexture || !newTexture->GetPixels())
   {
diff --git a/xbmc/guilib/TextureDX.cpp b/xbmc/guilib/TextureDX.cpp
index 1690adde38e20..65aa854163472 100644
--- a/xbmc/guilib/TextureDX.cpp
+++ b/xbmc/guilib/TextureDX.cpp
@@ -55,7 +55,7 @@ DXGI_FORMAT CDXTexture::GetFormat()
   case XB_FMT_A8R8G8B8:
     format = DXGI_FORMAT_B8G8R8A8_UNORM; // D3DFMT_A8R8G8B8 -> DXGI_FORMAT_B8G8R8A8_UNORM | DXGI_FORMAT_B8G8R8A8_UNORM_SRGB
     break;
-  case XB_FMT_A8:
+  case XB_FMT_R8:
     format = DXGI_FORMAT_R8_UNORM; // XB_FMT_A8 -> DXGI_FORMAT_A8_UNORM
     break;
   }
diff --git a/xbmc/guilib/TextureFormats.h b/xbmc/guilib/TextureFormats.h
index 95fff02092fb3..809d4e5b52463 100644
--- a/xbmc/guilib/TextureFormats.h
+++ b/xbmc/guilib/TextureFormats.h
@@ -8,6 +8,7 @@
 
 #pragma once
 
+// clang-format off
 #define XB_FMT_MASK   0xffff ///< mask for format info - other flags are outside this
 #define XB_FMT_DXT_MASK   15
 #define XB_FMT_UNKNOWN     0
@@ -16,7 +17,8 @@
 #define XB_FMT_DXT5        4
 #define XB_FMT_DXT5_YCoCg  8
 #define XB_FMT_A8R8G8B8   16 // texture.xbt byte order (matches BGRA8)
-#define XB_FMT_A8         32
+#define XB_FMT_R8         32 // Single channel, normally used as R,?,?,?
 #define XB_FMT_RGBA8      64
 #define XB_FMT_RGB8      128
 #define XB_FMT_OPAQUE  65536
+// clang-format on

From e40c15b9a6c1ef157eb4567b654f07463765d5fe Mon Sep 17 00:00:00 2001
From: sarbes <sarbes@kodi.tv>
Date: Sun, 12 Mar 2023 18:20:30 +0100
Subject: [PATCH 2/4] Add GLES shaders for single/dual channel textures

---
 ...s_shader_multi_blendcolor_alpha_alpha.frag | 44 +++++++++++++++
 ...s_shader_multi_blendcolor_alpha_color.frag | 43 +++++++++++++++
 ...s_shader_multi_blendcolor_color_alpha.frag | 43 +++++++++++++++
 .../GLES/2.0/gles_shader_texture_alpha.frag   | 40 ++++++++++++++
 xbmc/rendering/gles/RenderSystemGLES.cpp      | 55 +++++++++++++++++++
 xbmc/rendering/gles/RenderSystemGLES.h        |  8 +++
 6 files changed, 233 insertions(+)
 create mode 100644 system/shaders/GLES/2.0/gles_shader_multi_blendcolor_alpha_alpha.frag
 create mode 100644 system/shaders/GLES/2.0/gles_shader_multi_blendcolor_alpha_color.frag
 create mode 100644 system/shaders/GLES/2.0/gles_shader_multi_blendcolor_color_alpha.frag
 create mode 100644 system/shaders/GLES/2.0/gles_shader_texture_alpha.frag

diff --git a/system/shaders/GLES/2.0/gles_shader_multi_blendcolor_alpha_alpha.frag b/system/shaders/GLES/2.0/gles_shader_multi_blendcolor_alpha_alpha.frag
new file mode 100644
index 0000000000000..3bcb3c12cb075
--- /dev/null
+++ b/system/shaders/GLES/2.0/gles_shader_multi_blendcolor_alpha_alpha.frag
@@ -0,0 +1,44 @@
+/*
+ *      Copyright (C) 2010-2023 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#version 100
+
+precision mediump float;
+uniform sampler2D m_samp0;
+uniform sampler2D m_samp1;
+varying vec4 m_cord0;
+varying vec4 m_cord1;
+uniform lowp vec4 m_unicol;
+
+void main ()
+{
+  vec4 rgb;
+
+  rgb = m_unicol;
+  rgb.a *= texture2D(m_samp0, m_cord0.xy).a;
+  rgb.a *= texture2D(m_samp1, m_cord1.xy).a;
+
+#if defined(KODI_LIMITED_RANGE)
+  rgb.rgb *= (235.0 - 16.0) / 255.0;
+  rgb.rgb += 16.0 / 255.0;
+#endif
+
+  gl_FragColor = rgb;
+}
diff --git a/system/shaders/GLES/2.0/gles_shader_multi_blendcolor_alpha_color.frag b/system/shaders/GLES/2.0/gles_shader_multi_blendcolor_alpha_color.frag
new file mode 100644
index 0000000000000..7a60727df2f4b
--- /dev/null
+++ b/system/shaders/GLES/2.0/gles_shader_multi_blendcolor_alpha_color.frag
@@ -0,0 +1,43 @@
+/*
+ *      Copyright (C) 2010-2023 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#version 100
+
+precision mediump float;
+uniform sampler2D m_samp0;
+uniform sampler2D m_samp1;
+varying vec4 m_cord0;
+varying vec4 m_cord1;
+uniform lowp vec4 m_unicol;
+
+void main ()
+{
+  vec4 rgb;
+
+  rgb = m_unicol * texture2D(m_samp1, m_cord1.xy);
+  rgb.a *= texture2D(m_samp0, m_cord0.xy).a;
+
+#if defined(KODI_LIMITED_RANGE)
+  rgb.rgb *= (235.0 - 16.0) / 255.0;
+  rgb.rgb += 16.0 / 255.0;
+#endif
+
+  gl_FragColor = rgb;
+}
diff --git a/system/shaders/GLES/2.0/gles_shader_multi_blendcolor_color_alpha.frag b/system/shaders/GLES/2.0/gles_shader_multi_blendcolor_color_alpha.frag
new file mode 100644
index 0000000000000..11645c46b307d
--- /dev/null
+++ b/system/shaders/GLES/2.0/gles_shader_multi_blendcolor_color_alpha.frag
@@ -0,0 +1,43 @@
+/*
+ *      Copyright (C) 2010-2023 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#version 100
+
+precision mediump float;
+uniform sampler2D m_samp0;
+uniform sampler2D m_samp1;
+varying vec4 m_cord0;
+varying vec4 m_cord1;
+uniform lowp vec4 m_unicol;
+
+void main ()
+{
+  vec4 rgb;
+
+  rgb = m_unicol * texture2D(m_samp0, m_cord0.xy);
+  rgb.a *= texture2D(m_samp1, m_cord1.xy).a;
+
+#if defined(KODI_LIMITED_RANGE)
+  rgb.rgb *= (235.0 - 16.0) / 255.0;
+  rgb.rgb += 16.0 / 255.0;
+#endif
+
+  gl_FragColor = rgb;
+}
diff --git a/system/shaders/GLES/2.0/gles_shader_texture_alpha.frag b/system/shaders/GLES/2.0/gles_shader_texture_alpha.frag
new file mode 100644
index 0000000000000..900b46ec739b4
--- /dev/null
+++ b/system/shaders/GLES/2.0/gles_shader_texture_alpha.frag
@@ -0,0 +1,40 @@
+/*
+ *      Copyright (C) 2010-2023 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#version 100
+
+precision mediump float;
+uniform sampler2D m_samp0;
+uniform lowp vec4 m_unicol;
+varying vec4 m_cord0;
+
+void main ()
+{
+  vec4 rgb;
+  rgb = m_unicol;
+  rgb.a *= texture2D(m_samp0, m_cord0.xy).a;
+
+#if defined(KODI_LIMITED_RANGE)
+  rgb.rgb *= (235.0 - 16.0) / 255.0;
+  rgb.rgb += 16.0 / 255.0;
+#endif
+
+  gl_FragColor = rgb;
+}
diff --git a/xbmc/rendering/gles/RenderSystemGLES.cpp b/xbmc/rendering/gles/RenderSystemGLES.cpp
index d8557ff8a0f80..5bc66035ead61 100644
--- a/xbmc/rendering/gles/RenderSystemGLES.cpp
+++ b/xbmc/rendering/gles/RenderSystemGLES.cpp
@@ -407,6 +407,15 @@ void CRenderSystemGLES::InitialiseShaders()
     CLog::Log(LOGERROR, "GUI Shader gles_shader_texture.frag - compile and link failed");
   }
 
+  m_pShader[ShaderMethodGLES::SM_TEXTURE_ALPHA] =
+      std::make_unique<CGLESShader>("gles_shader_texture_alpha.frag", defines);
+  if (!m_pShader[ShaderMethodGLES::SM_TEXTURE_ALPHA]->CompileAndLink())
+  {
+    m_pShader[ShaderMethodGLES::SM_TEXTURE_ALPHA]->Free();
+    m_pShader[ShaderMethodGLES::SM_TEXTURE_ALPHA].reset();
+    CLog::Log(LOGERROR, "GUI Shader gles_shader_texture_alpha.frag - compile and link failed");
+  }
+
   m_pShader[ShaderMethodGLES::SM_MULTI] =
       std::make_unique<CGLESShader>("gles_shader_multi.frag", defines);
   if (!m_pShader[ShaderMethodGLES::SM_MULTI]->CompileAndLink())
@@ -443,6 +452,36 @@ void CRenderSystemGLES::InitialiseShaders()
     CLog::Log(LOGERROR, "GUI Shader gles_shader_multi_blendcolor.frag - compile and link failed");
   }
 
+  m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_COLOR_ALPHA] =
+      std::make_unique<CGLESShader>("gles_shader_multi_blendcolor_color_alpha.frag", defines);
+  if (!m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_COLOR_ALPHA]->CompileAndLink())
+  {
+    m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_COLOR_ALPHA]->Free();
+    m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_COLOR_ALPHA].reset();
+    CLog::Log(LOGERROR,
+              "GUI Shader gles_shader_multi_blendcolor_color_alpha.frag - compile and link failed");
+  }
+
+  m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_ALPHA_COLOR] =
+      std::make_unique<CGLESShader>("gles_shader_multi_blendcolor_alpha_color.frag", defines);
+  if (!m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_ALPHA_COLOR]->CompileAndLink())
+  {
+    m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_ALPHA_COLOR]->Free();
+    m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_ALPHA_COLOR].reset();
+    CLog::Log(LOGERROR,
+              "GUI Shader gles_shader_multi_blendcolor_alpha_color.frag - compile and link failed");
+  }
+
+  m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_ALPHA_ALPHA] =
+      std::make_unique<CGLESShader>("gles_shader_multi_blendcolor_alpha_alpha.frag", defines);
+  if (!m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_ALPHA_ALPHA]->CompileAndLink())
+  {
+    m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_ALPHA_ALPHA]->Free();
+    m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_ALPHA_ALPHA].reset();
+    CLog::Log(LOGERROR,
+              "GUI Shader gles_shader_multi_blendcolor_alpha_alpha.frag - compile and link failed");
+  }
+
   m_pShader[ShaderMethodGLES::SM_TEXTURE_RGBA] =
       std::make_unique<CGLESShader>("gles_shader_rgba.frag", defines);
   if (!m_pShader[ShaderMethodGLES::SM_TEXTURE_RGBA]->CompileAndLink())
@@ -512,6 +551,10 @@ void CRenderSystemGLES::ReleaseShaders()
     m_pShader[ShaderMethodGLES::SM_TEXTURE]->Free();
   m_pShader[ShaderMethodGLES::SM_TEXTURE].reset();
 
+  if (m_pShader[ShaderMethodGLES::SM_TEXTURE_ALPHA])
+    m_pShader[ShaderMethodGLES::SM_TEXTURE_ALPHA]->Free();
+  m_pShader[ShaderMethodGLES::SM_TEXTURE_ALPHA].reset();
+
   if (m_pShader[ShaderMethodGLES::SM_MULTI])
     m_pShader[ShaderMethodGLES::SM_MULTI]->Free();
   m_pShader[ShaderMethodGLES::SM_MULTI].reset();
@@ -528,6 +571,18 @@ void CRenderSystemGLES::ReleaseShaders()
     m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR]->Free();
   m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR].reset();
 
+  if (m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_COLOR_ALPHA])
+    m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_COLOR_ALPHA]->Free();
+  m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_COLOR_ALPHA].reset();
+
+  if (m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_ALPHA_COLOR])
+    m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_ALPHA_COLOR]->Free();
+  m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_ALPHA_COLOR].reset();
+
+  if (m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_ALPHA_ALPHA])
+    m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_ALPHA_ALPHA]->Free();
+  m_pShader[ShaderMethodGLES::SM_MULTI_BLENDCOLOR_ALPHA_ALPHA].reset();
+
   if (m_pShader[ShaderMethodGLES::SM_TEXTURE_RGBA])
     m_pShader[ShaderMethodGLES::SM_TEXTURE_RGBA]->Free();
   m_pShader[ShaderMethodGLES::SM_TEXTURE_RGBA].reset();
diff --git a/xbmc/rendering/gles/RenderSystemGLES.h b/xbmc/rendering/gles/RenderSystemGLES.h
index e0cd72b9c1937..31b4abbaa9d04 100644
--- a/xbmc/rendering/gles/RenderSystemGLES.h
+++ b/xbmc/rendering/gles/RenderSystemGLES.h
@@ -23,10 +23,14 @@ enum class ShaderMethodGLES
 {
   SM_DEFAULT,
   SM_TEXTURE,
+  SM_TEXTURE_ALPHA,
   SM_MULTI,
   SM_FONTS,
   SM_TEXTURE_NOBLEND,
   SM_MULTI_BLENDCOLOR,
+  SM_MULTI_BLENDCOLOR_COLOR_ALPHA,
+  SM_MULTI_BLENDCOLOR_ALPHA_COLOR,
+  SM_MULTI_BLENDCOLOR_ALPHA_ALPHA,
   SM_TEXTURE_RGBA,
   SM_TEXTURE_RGBA_OES,
   SM_TEXTURE_RGBA_BLENDCOLOR,
@@ -53,10 +57,14 @@ struct fmt::formatter<ShaderMethodGLES> : fmt::formatter<std::string_view>
   static constexpr auto ShaderMethodGLESMap = make_map<ShaderMethodGLES, std::string_view>({
       {ShaderMethodGLES::SM_DEFAULT, "default"},
       {ShaderMethodGLES::SM_TEXTURE, "texture"},
+      {ShaderMethodGLES::SM_TEXTURE_ALPHA, "texture, alpha only"},
       {ShaderMethodGLES::SM_MULTI, "multi"},
       {ShaderMethodGLES::SM_FONTS, "fonts"},
       {ShaderMethodGLES::SM_TEXTURE_NOBLEND, "texture no blending"},
       {ShaderMethodGLES::SM_MULTI_BLENDCOLOR, "multi blend colour"},
+      {ShaderMethodGLES::SM_MULTI_BLENDCOLOR_COLOR_ALPHA, "multi blend colour and alpha texture"},
+      {ShaderMethodGLES::SM_MULTI_BLENDCOLOR_ALPHA_COLOR, "multi blend alpha and colour texture"},
+      {ShaderMethodGLES::SM_MULTI_BLENDCOLOR_ALPHA_ALPHA, "multi blend alpha textures"},
       {ShaderMethodGLES::SM_TEXTURE_RGBA, "texure rgba"},
       {ShaderMethodGLES::SM_TEXTURE_RGBA_OES, "texture rgba OES"},
       {ShaderMethodGLES::SM_TEXTURE_RGBA_BLENDCOLOR, "texture rgba blend colour"},

From 785e7d847c3a4ff6bf16841c729b0d02a711c441 Mon Sep 17 00:00:00 2001
From: sarbes <sarbes@kodi.tv>
Date: Mon, 13 Mar 2023 01:39:32 +0100
Subject: [PATCH 3/4] Implement single/dual channel textures for GL/GLES

---
 xbmc/guilib/FFmpegImage.cpp    |  66 ++++++++++++++++---
 xbmc/guilib/FFmpegImage.h      |   8 ++-
 xbmc/guilib/GUITextureGLES.cpp |  22 ++++++-
 xbmc/guilib/Texture.cpp        | 115 ++++++++++++++++++++++++++++-----
 xbmc/guilib/Texture.h          |  19 ++++--
 xbmc/guilib/TextureDX.cpp      |  18 ++++++
 xbmc/guilib/TextureDX.h        |   1 +
 xbmc/guilib/TextureFormats.h   |   3 +
 xbmc/guilib/TextureGL.cpp      | 114 ++++++++++++++++++++++++++++++++
 xbmc/guilib/TextureGL.h        |   1 +
 xbmc/guilib/TextureManager.cpp |  18 +++++-
 xbmc/guilib/iimage.h           |  15 ++++-
 12 files changed, 362 insertions(+), 38 deletions(-)

diff --git a/xbmc/guilib/FFmpegImage.cpp b/xbmc/guilib/FFmpegImage.cpp
index e71980998b2e5..a0d3fd14c9cfe 100644
--- a/xbmc/guilib/FFmpegImage.cpp
+++ b/xbmc/guilib/FFmpegImage.cpp
@@ -300,6 +300,13 @@ AVFrame* CFFmpegImage::ExtractFrame()
   m_originalWidth = m_width;
   m_originalHeight = m_height;
 
+  if (frame->format == AV_PIX_FMT_GRAY8)
+    m_format = XB_FMT_L8;
+  else if (frame->format == AV_PIX_FMT_GRAY8A)
+    m_format = XB_FMT_L8A8;
+  else
+    m_format = XB_FMT_A8R8G8B8;
+
   const AVPixFmtDescriptor* pixDescriptor = av_pix_fmt_desc_get(static_cast<AVPixelFormat>(frame->format));
   if (pixDescriptor && ((pixDescriptor->flags & (AV_PIX_FMT_FLAG_ALPHA | AV_PIX_FMT_FLAG_PAL)) != 0))
     m_hasAlpha = true;
@@ -349,12 +356,43 @@ void CFFmpegImage::FreeIOCtx(AVIOContext** ioctx)
   av_freep(ioctx);
 }
 
-bool CFFmpegImage::Decode(unsigned char * const pixels, unsigned int width, unsigned int height,
-                          unsigned int pitch, unsigned int format)
+bool CFFmpegImage::IsFormatSupported(uint32_t format)
+{
+  switch (format)
+  {
+    case XB_FMT_A8:
+    case XB_FMT_L8:
+    case XB_FMT_L8A8:
+    case XB_FMT_A8R8G8B8:
+      return true;
+    default:
+      return false;
+  }
+}
+
+bool CFFmpegImage::Decode(unsigned char* const pixels,
+                          unsigned int width,
+                          unsigned int height,
+                          unsigned int pitch,
+                          unsigned int textureFormat)
 {
-  if (m_width == 0 || m_height == 0 || format != XB_FMT_A8R8G8B8)
+  if (m_width == 0 || m_height == 0)
     return false;
 
+  AVPixelFormat outputPixelFormat;
+  if (textureFormat == XB_FMT_A8 || textureFormat == XB_FMT_L8)
+    outputPixelFormat = AV_PIX_FMT_GRAY8;
+  else if (textureFormat == XB_FMT_L8A8)
+    outputPixelFormat = AV_PIX_FMT_GRAY8A;
+  else if (textureFormat == XB_FMT_RGB8 || textureFormat == XB_FMT_A8R8G8B8 ||
+           textureFormat == XB_FMT_RGBA8)
+    outputPixelFormat = AV_PIX_FMT_RGB32;
+  else
+  {
+    CLog::Log(LOGERROR, "{} - No valid texture format ({}) passed", __FUNCTION__, textureFormat);
+    return false;
+  }
+
   if (pixels == nullptr)
   {
     CLog::Log(LOGERROR, "{} - No valid buffer pointer (nullptr) passed", __FUNCTION__);
@@ -367,7 +405,10 @@ bool CFFmpegImage::Decode(unsigned char * const pixels, unsigned int width, unsi
     return false;
   }
 
-  return DecodeFrame(m_pFrame, width, height, pitch, pixels);
+  bool success = DecodeFrame(m_pFrame, width, height, pitch, pixels, outputPixelFormat);
+  if (textureFormat == XB_FMT_A8)
+    m_hasAlpha = true;
+  return success;
 }
 
 int CFFmpegImage::EncodeFFmpegFrame(AVCodecContext *avctx, AVPacket *pkt, int *got_packet, AVFrame *frame)
@@ -414,7 +455,12 @@ int CFFmpegImage::DecodeFFmpegFrame(AVCodecContext *avctx, AVFrame *frame, int *
   return 0;
 }
 
-bool CFFmpegImage::DecodeFrame(AVFrame* frame, unsigned int width, unsigned int height, unsigned int pitch, unsigned char * const pixels)
+bool CFFmpegImage::DecodeFrame(AVFrame* frame,
+                               unsigned int width,
+                               unsigned int height,
+                               unsigned int pitch,
+                               unsigned char* const pixels,
+                               AVPixelFormat outputPixelFormat)
 {
   if (pixels == nullptr)
   {
@@ -430,7 +476,8 @@ bool CFFmpegImage::DecodeFrame(AVFrame* frame, unsigned int width, unsigned int
   }
 
   // we align on 16 as the input provided by the Texture also aligns the buffer size to 16
-  int size = av_image_fill_arrays(pictureRGB->data, pictureRGB->linesize, NULL, AV_PIX_FMT_RGB32, width, height, 16);
+  int size = av_image_fill_arrays(pictureRGB->data, pictureRGB->linesize, NULL, outputPixelFormat,
+                                  width, height, 16);
   if (size < 0)
   {
     CLog::LogF(LOGERROR, "Could not allocate AVFrame member with {} x {} pixels", width, height);
@@ -452,7 +499,7 @@ bool CFFmpegImage::DecodeFrame(AVFrame* frame, unsigned int width, unsigned int
   else
   {
     // We need an extra buffer and copy it manually afterwards
-    pictureRGB->format = AV_PIX_FMT_RGB32;
+    pictureRGB->format = outputPixelFormat;
     pictureRGB->width = width;
     pictureRGB->height = height;
     // we copy the data manually later so give a chance to intrinsics (e.g. mmx, neon)
@@ -485,8 +532,9 @@ bool CFFmpegImage::DecodeFrame(AVFrame* frame, unsigned int width, unsigned int
     nHeight = (unsigned int)(nWidth / ratio + 0.5f);
   }
 
-  struct SwsContext* context = sws_getContext(m_originalWidth, m_originalHeight, pixFormat,
-    nWidth, nHeight, AV_PIX_FMT_RGB32, SWS_BICUBIC, NULL, NULL, NULL);
+  struct SwsContext* context =
+      sws_getContext(m_originalWidth, m_originalHeight, pixFormat, nWidth, nHeight,
+                     outputPixelFormat, SWS_BICUBIC, NULL, NULL, NULL);
 
   if (range == AVCOL_RANGE_JPEG)
   {
diff --git a/xbmc/guilib/FFmpegImage.h b/xbmc/guilib/FFmpegImage.h
index 0f7cee380c253..7be0df1eeb116 100644
--- a/xbmc/guilib/FFmpegImage.h
+++ b/xbmc/guilib/FFmpegImage.h
@@ -60,6 +60,7 @@ class CFFmpegImage : public IImage
 
   bool LoadImageFromMemory(unsigned char* buffer, unsigned int bufSize,
                            unsigned int width, unsigned int height) override;
+  bool IsFormatSupported(uint32_t format) override;
   bool Decode(unsigned char * const pixels, unsigned int width, unsigned int height,
               unsigned int pitch, unsigned int format) override;
   bool CreateThumbnailFromSurface(unsigned char* bufferin, unsigned int width,
@@ -76,7 +77,12 @@ class CFFmpegImage : public IImage
 private:
   static void FreeIOCtx(AVIOContext** ioctx);
   AVFrame* ExtractFrame();
-  bool DecodeFrame(AVFrame* m_pFrame, unsigned int width, unsigned int height, unsigned int pitch, unsigned char * const pixels);
+  bool DecodeFrame(AVFrame* m_pFrame,
+                   unsigned int width,
+                   unsigned int height,
+                   unsigned int pitch,
+                   unsigned char* const pixels,
+                   AVPixelFormat textureFormat = AV_PIX_FMT_RGB32);
   static int EncodeFFmpegFrame(AVCodecContext *avctx, AVPacket *pkt, int *got_packet, AVFrame *frame);
   static int DecodeFFmpegFrame(AVCodecContext *avctx, AVFrame *frame, int *got_frame, AVPacket *pkt);
   static AVPixelFormat ConvertFormats(AVFrame* frame);
diff --git a/xbmc/guilib/GUITextureGLES.cpp b/xbmc/guilib/GUITextureGLES.cpp
index d92201ae7fcce..7830c56feb527 100644
--- a/xbmc/guilib/GUITextureGLES.cpp
+++ b/xbmc/guilib/GUITextureGLES.cpp
@@ -65,10 +65,24 @@ void CGUITextureGLES::Begin(UTILS::COLOR::Color color)
   }
 
   bool hasAlpha = m_texture.m_textures[m_currentFrame]->HasAlpha() || m_col[3] < 255;
+  bool alphaOnlyTexture = m_texture.m_textures[m_currentFrame]->IsAlphaTexture();
 
   if (m_diffuse.size())
   {
-    if (m_col[0] == 255 && m_col[1] == 255 && m_col[2] == 255 && m_col[3] == 255 )
+    bool alphaOnlyDiffuse = m_diffuse.m_textures[0]->IsAlphaTexture();
+    if (alphaOnlyTexture && alphaOnlyDiffuse)
+    {
+      m_renderSystem->EnableGUIShader(ShaderMethodGLES::SM_MULTI_BLENDCOLOR_ALPHA_ALPHA);
+    }
+    else if (alphaOnlyTexture)
+    {
+      m_renderSystem->EnableGUIShader(ShaderMethodGLES::SM_MULTI_BLENDCOLOR_ALPHA_COLOR);
+    }
+    else if (alphaOnlyDiffuse)
+    {
+      m_renderSystem->EnableGUIShader(ShaderMethodGLES::SM_MULTI_BLENDCOLOR_COLOR_ALPHA);
+    }
+    else if (m_col[0] == 255 && m_col[1] == 255 && m_col[2] == 255 && m_col[3] == 255)
     {
       m_renderSystem->EnableGUIShader(ShaderMethodGLES::SM_MULTI);
     }
@@ -84,7 +98,11 @@ void CGUITextureGLES::Begin(UTILS::COLOR::Color color)
   }
   else
   {
-    if (m_col[0] == 255 && m_col[1] == 255 && m_col[2] == 255 && m_col[3] == 255)
+    if (alphaOnlyTexture)
+    {
+      m_renderSystem->EnableGUIShader(ShaderMethodGLES::SM_TEXTURE_ALPHA);
+    }
+    else if (m_col[0] == 255 && m_col[1] == 255 && m_col[2] == 255 && m_col[3] == 255)
     {
       m_renderSystem->EnableGUIShader(ShaderMethodGLES::SM_TEXTURE_NOBLEND);
     }
diff --git a/xbmc/guilib/Texture.cpp b/xbmc/guilib/Texture.cpp
index 4a2f80e3622d2..166326db5252f 100644
--- a/xbmc/guilib/Texture.cpp
+++ b/xbmc/guilib/Texture.cpp
@@ -15,6 +15,7 @@
 #include "filesystem/File.h"
 #include "filesystem/ResourceFile.h"
 #include "filesystem/XbtFile.h"
+#include "guilib/TextureFormats.h"
 #include "guilib/iimage.h"
 #include "guilib/imagefactory.h"
 #include "utils/URIUtils.h"
@@ -50,7 +51,7 @@ CTexture::~CTexture()
   m_pixels = NULL;
 }
 
-void CTexture::Allocate(unsigned int width, unsigned int height, unsigned int format)
+void CTexture::Allocate(unsigned int width, unsigned int height, unsigned int format, bool scalable)
 {
   m_imageWidth = m_originalWidth = width;
   m_imageHeight = m_originalHeight = height;
@@ -78,7 +79,7 @@ void CTexture::Allocate(unsigned int width, unsigned int height, unsigned int fo
     m_textureWidth = ((m_textureWidth + 3) / 4) * 4;
     m_textureHeight = ((m_textureHeight + 3) / 4) * 4;
   }
-  else
+  else if (scalable)
   {
     // align all textures so that they have an even width
     // in some circumstances when we downsize a thumbnail
@@ -102,9 +103,9 @@ void CTexture::Allocate(unsigned int width, unsigned int height, unsigned int fo
 
   KODI::MEMORY::AlignedFree(m_pixels);
   m_pixels = NULL;
-  if (GetPitch() * GetRows() > 0)
+  if (GetPitch(m_textureWidth, m_format) * GetRows(m_textureHeight, m_format) > 0)
   {
-    size_t size = GetPitch() * GetRows();
+    size_t size = GetPitch(m_textureWidth, m_format) * GetRows(m_textureHeight, m_format);
     m_pixels = static_cast<unsigned char*>(KODI::MEMORY::AlignedMalloc(size, 32));
 
     if (m_pixels == nullptr)
@@ -127,15 +128,18 @@ void CTexture::Update(unsigned int width,
   if (format & XB_FMT_DXT_MASK)
     return;
 
-  Allocate(width, height, format);
+  if (IsGPUFormatSupported(format))
+    Allocate(width, height, format, false);
+  else
+    Allocate(width, height, XB_FMT_A8R8G8B8, false);
 
   if (m_pixels == nullptr)
     return;
 
-  unsigned int srcPitch = pitch ? pitch : GetPitch(width);
-  unsigned int srcRows = GetRows(height);
-  unsigned int dstPitch = GetPitch(m_textureWidth);
-  unsigned int dstRows = GetRows(m_textureHeight);
+  unsigned int srcPitch = pitch ? pitch : GetPitch(width, format);
+  unsigned int srcRows = GetRows(height, format);
+  unsigned int dstPitch = GetPitch(m_textureWidth, format);
+  unsigned int dstRows = GetRows(m_textureHeight, format);
 
   if (srcPitch == dstPitch)
     memcpy(m_pixels, pixels, srcPitch * std::min(srcRows, dstRows));
@@ -150,6 +154,10 @@ void CTexture::Update(unsigned int width,
       dst += dstPitch;
     }
   }
+
+  if (!IsGPUFormatSupported(format))
+    ConvertToBGRA(format);
+
   ClampToEdge();
 
   if (loadToGPU)
@@ -193,7 +201,8 @@ std::unique_ptr<CTexture> CTexture::LoadFromFile(const std::string& texturePath,
                                                  unsigned int idealWidth,
                                                  unsigned int idealHeight,
                                                  bool requirePixels,
-                                                 const std::string& strMimeType)
+                                                 const std::string& strMimeType,
+                                                 unsigned int format)
 {
 #if defined(TARGET_ANDROID)
   CURL url(texturePath);
@@ -217,7 +226,7 @@ std::unique_ptr<CTexture> CTexture::LoadFromFile(const std::string& texturePath,
     }
   }
 #endif
-  std::unique_ptr<CTexture> texture = CTexture::CreateTexture();
+  std::unique_ptr<CTexture> texture = CTexture::CreateTexture(0, 0, format);
   if (texture->LoadFromFileInternal(texturePath, idealWidth, idealHeight, requirePixels, strMimeType))
     return texture;
   return {};
@@ -227,9 +236,10 @@ std::unique_ptr<CTexture> CTexture::LoadFromFileInMemory(unsigned char* buffer,
                                                          size_t bufferSize,
                                                          const std::string& mimeType,
                                                          unsigned int idealWidth,
-                                                         unsigned int idealHeight)
+                                                         unsigned int idealHeight,
+                                                         unsigned int format)
 {
-  std::unique_ptr<CTexture> texture = CTexture::CreateTexture();
+  std::unique_ptr<CTexture> texture = CTexture::CreateTexture(0, 0, format);
   if (texture->LoadFromFileInMem(buffer, bufferSize, mimeType, idealWidth, idealHeight))
     return texture;
   return {};
@@ -336,8 +346,18 @@ bool CTexture::LoadIImage(IImage* pImage,
   {
     if (pImage->Width() > 0 && pImage->Height() > 0)
     {
-      Allocate(pImage->Width(), pImage->Height(), XB_FMT_A8R8G8B8);
-      if (m_pixels != nullptr && pImage->Decode(m_pixels, GetTextureWidth(), GetRows(), GetPitch(), XB_FMT_A8R8G8B8))
+      // if we don't request a specific format, the decoder can suggest a compatible one.
+      if (m_format == XB_FMT_UNKNOWN)
+        m_format = pImage->GetCompatibleFormat();
+      // if the decoder can't write to the texture, fall back to our standard four channel texture
+      else if (!pImage->IsFormatSupported(m_format))
+        m_format = XB_FMT_A8R8G8B8;
+      // if not supported on the GPU, we fall back
+      if (!IsGPUFormatSupported(m_format))
+        m_format = XB_FMT_A8R8G8B8;
+      Allocate(pImage->Width(), pImage->Height(), m_format);
+      if (m_pixels != nullptr &&
+          pImage->Decode(m_pixels, GetTextureWidth(), GetRows(), GetPitch(), m_format))
       {
         if (pImage->Orientation())
           m_orientation = pImage->Orientation() - 1;
@@ -428,7 +448,12 @@ bool CTexture::SwapBlueRed(unsigned char* pixels,
 
 unsigned int CTexture::GetPitch(unsigned int width) const
 {
-  switch (m_format)
+  return GetPitch(width, m_format);
+}
+
+unsigned int CTexture::GetPitch(unsigned int width, unsigned int format) const
+{
+  switch (format)
   {
   case XB_FMT_DXT1:
     return ((width + 3) / 4) * 8;
@@ -436,8 +461,12 @@ unsigned int CTexture::GetPitch(unsigned int width) const
   case XB_FMT_DXT5:
   case XB_FMT_DXT5_YCoCg:
     return ((width + 3) / 4) * 16;
+  case XB_FMT_R8:
   case XB_FMT_A8:
+  case XB_FMT_L8:
     return width;
+  case XB_FMT_L8A8:
+    return width * 2;
   case XB_FMT_RGB8:
     return (((width + 1)* 3 / 4) * 4);
   case XB_FMT_RGBA8:
@@ -449,7 +478,12 @@ unsigned int CTexture::GetPitch(unsigned int width) const
 
 unsigned int CTexture::GetRows(unsigned int height) const
 {
-  switch (m_format)
+  return GetRows(height, m_format);
+}
+
+unsigned int CTexture::GetRows(unsigned int height, unsigned int format) const
+{
+  switch (format)
   {
   case XB_FMT_DXT1:
     return (height + 3) / 4;
@@ -473,7 +507,11 @@ unsigned int CTexture::GetBlockSize() const
   case XB_FMT_DXT5_YCoCg:
     return 16;
   case XB_FMT_A8:
+  case XB_FMT_L8:
+  case XB_FMT_R8:
     return 1;
+  case XB_FMT_L8A8:
+    return 2;
   default:
     return 4;
   }
@@ -484,6 +522,11 @@ bool CTexture::HasAlpha() const
   return m_hasAlpha;
 }
 
+bool CTexture::IsAlphaTexture() const
+{
+  return m_format == XB_FMT_A8;
+}
+
 void CTexture::SetMipmapping()
 {
   m_mipmapping = true;
@@ -493,3 +536,41 @@ bool CTexture::IsMipmapped() const
 {
   return m_mipmapping;
 }
+
+void CTexture::ConvertToBGRA(uint32_t format)
+{
+  size_t size = GetPitch(m_textureWidth, format) * GetRows(m_textureHeight, format);
+
+  if (format == XB_FMT_A8)
+  {
+    for (int32_t i = size - 1; i >= 0; i--)
+    {
+      m_pixels[i * 4 + 3] = m_pixels[i];
+      m_pixels[i * 4 + 2] = char(0xff);
+      m_pixels[i * 4 + 1] = char(0xff);
+      m_pixels[i * 4] = char(0xff);
+    }
+  }
+  else if (format == XB_FMT_L8)
+  {
+    for (int32_t i = size - 1; i >= 0; i--)
+    {
+      m_pixels[i * 4 + 3] = char(0xff);
+      m_pixels[i * 4 + 2] = m_pixels[i];
+      m_pixels[i * 4 + 1] = m_pixels[i];
+      m_pixels[i * 4] = m_pixels[i];
+    }
+  }
+  else if (format == XB_FMT_L8A8)
+  {
+    for (int32_t i = size / 2 - 1; i >= 0; i--)
+    {
+      m_pixels[i * 4 + 3] = m_pixels[i * 2 + 1];
+      m_pixels[i * 4 + 2] = m_pixels[i * 2];
+      m_pixels[i * 4 + 1] = m_pixels[i * 2];
+      m_pixels[i * 4] = m_pixels[i * 2];
+    }
+  }
+
+  m_format = XB_FMT_A8R8G8B8;
+}
diff --git a/xbmc/guilib/Texture.h b/xbmc/guilib/Texture.h
index 343e9968bf53d..95b181f423f6b 100644
--- a/xbmc/guilib/Texture.h
+++ b/xbmc/guilib/Texture.h
@@ -55,7 +55,8 @@ class CTexture
                                                 unsigned int idealWidth = 0,
                                                 unsigned int idealHeight = 0,
                                                 bool requirePixels = false,
-                                                const std::string& strMimeType = "");
+                                                const std::string& strMimeType = "",
+                                                unsigned int format = XB_FMT_A8R8G8B8);
 
   /*! \brief Load a texture from a file in memory
    Loads a texture from a file in memory, restricting in size if needed based on maxHeight and maxWidth.
@@ -71,12 +72,14 @@ class CTexture
                                                         size_t bufferSize,
                                                         const std::string& mimeType,
                                                         unsigned int idealWidth = 0,
-                                                        unsigned int idealHeight = 0);
+                                                        unsigned int idealHeight = 0,
+                                                        unsigned int format = XB_FMT_A8R8G8B8);
 
   bool LoadFromMemory(unsigned int width, unsigned int height, unsigned int pitch, unsigned int format, bool hasAlpha, const unsigned char* pixels);
   bool LoadPaletted(unsigned int width, unsigned int height, unsigned int pitch, unsigned int format, const unsigned char *pixels, const COLOR *palette);
 
   bool HasAlpha() const;
+  bool IsAlphaTexture() const;
 
   void SetMipmapping();
   bool IsMipmapped() const;
@@ -91,8 +94,8 @@ class CTexture
   virtual void BindToUnit(unsigned int unit) = 0;
 
   unsigned char* GetPixels() const { return m_pixels; }
-  unsigned int GetPitch() const { return GetPitch(m_textureWidth); }
-  unsigned int GetRows() const { return GetRows(m_textureHeight); }
+  unsigned int GetPitch() const { return GetPitch(m_textureWidth, m_format); }
+  unsigned int GetRows() const { return GetRows(m_textureHeight, m_format); }
   unsigned int GetTextureWidth() const { return m_textureWidth; }
   unsigned int GetTextureHeight() const { return m_textureHeight; }
   unsigned int GetWidth() const { return m_imageWidth; }
@@ -106,12 +109,14 @@ class CTexture
   void SetOrientation(int orientation) { m_orientation = orientation; }
 
   void Update(unsigned int width, unsigned int height, unsigned int pitch, unsigned int format, const unsigned char *pixels, bool loadToGPU);
-  void Allocate(unsigned int width, unsigned int height, unsigned int format);
+  void Allocate(unsigned int width, unsigned int height, unsigned int format, bool scalable = true);
   void ClampToEdge();
 
   static unsigned int PadPow2(unsigned int x);
   static bool SwapBlueRed(unsigned char *pixels, unsigned int height, unsigned int pitch, unsigned int elements = 4, unsigned int offset=0);
 
+  virtual bool IsGPUFormatSupported(const uint32_t format) { return format == XB_FMT_A8R8G8B8; }
+
 private:
   // no copy constructor
   CTexture(const CTexture& copy) = delete;
@@ -123,9 +128,13 @@ class CTexture
   bool LoadIImage(IImage* pImage, unsigned char* buffer, unsigned int bufSize, unsigned int width, unsigned int height);
   // helpers for computation of texture parameters for compressed textures
   unsigned int GetPitch(unsigned int width) const;
+  unsigned int GetPitch(unsigned int width, unsigned int format) const;
   unsigned int GetRows(unsigned int height) const;
+  unsigned int GetRows(unsigned int height, unsigned int format) const;
   unsigned int GetBlockSize() const;
 
+  void ConvertToBGRA(uint32_t format);
+
   unsigned int m_imageWidth;
   unsigned int m_imageHeight;
   unsigned int m_textureWidth;
diff --git a/xbmc/guilib/TextureDX.cpp b/xbmc/guilib/TextureDX.cpp
index 65aa854163472..2ce799e3f8645 100644
--- a/xbmc/guilib/TextureDX.cpp
+++ b/xbmc/guilib/TextureDX.cpp
@@ -191,3 +191,21 @@ void CDXTexture::LoadToGPU()
 void CDXTexture::BindToUnit(unsigned int unit)
 {
 }
+
+bool CDXTexture::IsGPUFormatSupported(uint32_t format)
+{
+  switch (format)
+  {
+    case XB_FMT_A8R8G8B8:
+    case XB_FMT_RGB8:
+    case XB_FMT_R8:
+    case XB_FMT_DXT1:
+    case XB_FMT_DXT3:
+    case XB_FMT_DXT5:
+    case XB_FMT_DXT5_YCoCg:
+      //FIXME: actually return supported compression
+      return true;
+    default:
+      return false;
+  }
+}
diff --git a/xbmc/guilib/TextureDX.h b/xbmc/guilib/TextureDX.h
index 0858780df2f16..0bb9d3bfd0b4f 100644
--- a/xbmc/guilib/TextureDX.h
+++ b/xbmc/guilib/TextureDX.h
@@ -24,6 +24,7 @@ class CDXTexture : public CTexture
   void DestroyTextureObject();
   virtual void LoadToGPU();
   void BindToUnit(unsigned int unit);
+  bool IsGPUFormatSupported(const uint32_t format) override;
 
   ID3D11Texture2D* GetTextureObject()
   {
diff --git a/xbmc/guilib/TextureFormats.h b/xbmc/guilib/TextureFormats.h
index 809d4e5b52463..5ae3dced9c462 100644
--- a/xbmc/guilib/TextureFormats.h
+++ b/xbmc/guilib/TextureFormats.h
@@ -20,5 +20,8 @@
 #define XB_FMT_R8         32 // Single channel, normally used as R,?,?,?
 #define XB_FMT_RGBA8      64
 #define XB_FMT_RGB8      128
+#define XB_FMT_A8        256 // Single channel, used as 1,1,1,A (alpha)
+#define XB_FMT_L8        272 // Single channel, used as L,L,L,1 (luma)
+#define XB_FMT_L8A8      288 // Dual channel, used as L,L,L,A (lumaalpha)
 #define XB_FMT_OPAQUE  65536
 // clang-format on
diff --git a/xbmc/guilib/TextureGL.cpp b/xbmc/guilib/TextureGL.cpp
index ef01bdf540196..9cfe999311496 100644
--- a/xbmc/guilib/TextureGL.cpp
+++ b/xbmc/guilib/TextureGL.cpp
@@ -110,7 +110,50 @@ void CGLTexture::LoadToGPU()
     m_textureWidth = maxSize;
   }
 
+  if (m_format == XB_FMT_A8 || m_format == XB_FMT_L8)
+    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+  else if (m_format == XB_FMT_L8A8)
+    glPixelStorei(GL_UNPACK_ALIGNMENT, 2);
+
 #ifndef HAS_GLES
+
+#ifndef GL_RED
+#define GL_RED 0x1903
+#endif
+#ifndef GL_GREEN
+#define GL_GREEN 0x1904
+#endif
+#ifndef GL_RG
+#define GL_RG 0x8227
+#endif
+#ifndef GL_TEXTURE_SWIZZLE_RGBA
+#define GL_TEXTURE_SWIZZLE_RGBA 0x8E46
+#endif
+
+  if (CServiceBroker::GetRenderSystem()->IsExtSupported("GL_ARB_texture_swizzle"))
+  {
+    if (m_format == XB_FMT_A8)
+    {
+      GLint const swizzle[] = {GL_ONE, GL_ONE, GL_ONE, GL_RED};
+      glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_RGBA, swizzle);
+    }
+    else if (m_format == XB_FMT_L8)
+    {
+      GLint const swizzle[] = {GL_RED, GL_RED, GL_RED, GL_ONE};
+      glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_RGBA, swizzle);
+    }
+    else if (m_format == XB_FMT_L8A8)
+    {
+      GLint const swizzle[] = {GL_RED, GL_RED, GL_RED, GL_GREEN};
+      glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_RGBA, swizzle);
+    }
+  }
+  else if (m_format == XB_FMT_A8 || m_format == XB_FMT_L8 || m_format == XB_FMT_L8A8)
+  {
+    CLog::Log(LOGERROR, "{} Attempted to upload an unsupported texture", __FUNCTION__);
+    return;
+  }
+
   GLenum format = GL_BGRA;
   GLint numcomponents = GL_RGBA;
 
@@ -130,6 +173,16 @@ void CGLTexture::LoadToGPU()
     format = GL_RGB;
     numcomponents = GL_RGB;
     break;
+  case XB_FMT_A8:
+  case XB_FMT_L8:
+  case XB_FMT_R8:
+    format = GL_RED;
+    numcomponents = GL_RED;
+    break;
+  case XB_FMT_L8A8:
+    format = GL_RG;
+    numcomponents = GL_RG;
+    break;
   case XB_FMT_A8R8G8B8:
   default:
     break;
@@ -164,6 +217,9 @@ void CGLTexture::LoadToGPU()
   // system headers, and trust the extension list instead.
 #ifndef GL_BGRA_EXT
 #define GL_BGRA_EXT 0x80E1
+#endif
+#ifndef GL_RED
+#define GL_RED 0x1903
 #endif
 
   GLint internalformat;
@@ -178,6 +234,21 @@ void CGLTexture::LoadToGPU()
     case XB_FMT_RGB8:
       internalformat = pixelformat = GL_RGB;
       break;
+    case XB_FMT_A8:
+      internalformat = pixelformat = GL_ALPHA;
+      break;
+    case XB_FMT_L8:
+      internalformat = pixelformat = GL_LUMINANCE;
+      break;
+    case XB_FMT_R8:
+      if (m_isOglVersion3orNewer)
+        internalformat = pixelformat = GL_RED;
+      else
+        internalformat = pixelformat = GL_LUMINANCE;
+      break;
+    case XB_FMT_L8A8:
+      internalformat = pixelformat = GL_LUMINANCE_ALPHA;
+      break;
     case XB_FMT_A8R8G8B8:
       if (CServiceBroker::GetRenderSystem()->IsExtSupported("GL_EXT_texture_format_BGRA8888") ||
           CServiceBroker::GetRenderSystem()->IsExtSupported("GL_IMG_texture_format_BGRA8888"))
@@ -216,6 +287,7 @@ void CGLTexture::LoadToGPU()
   }
 
   m_loadedToGPU = true;
+  glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
 }
 
 void CGLTexture::BindToUnit(unsigned int unit)
@@ -224,3 +296,45 @@ void CGLTexture::BindToUnit(unsigned int unit)
   glBindTexture(GL_TEXTURE_2D, m_texture);
 }
 
+bool CGLTexture::IsGPUFormatSupported(const uint32_t format)
+{
+#ifdef HAS_GL
+  switch (format)
+  {
+    case XB_FMT_A8R8G8B8:
+    case XB_FMT_RGB8:
+    case XB_FMT_RGBA8:
+      return true;
+    case XB_FMT_L8:
+    case XB_FMT_A8:
+    case XB_FMT_L8A8:
+      return CServiceBroker::GetRenderSystem()->IsExtSupported("GL_ARB_texture_swizzle");
+    case XB_FMT_DXT1:
+    case XB_FMT_DXT3:
+    case XB_FMT_DXT5:
+    case XB_FMT_DXT5_YCoCg:
+      //FIXME: actually return supported compression
+      return true;
+    default:
+      return false;
+  }
+#else
+  switch (format)
+  {
+    case XB_FMT_A8R8G8B8:
+    case XB_FMT_RGB8:
+    case XB_FMT_RGBA8:
+    case XB_FMT_L8:
+    case XB_FMT_A8:
+    case XB_FMT_L8A8:
+    case XB_FMT_DXT1:
+    case XB_FMT_DXT3:
+    case XB_FMT_DXT5:
+    case XB_FMT_DXT5_YCoCg:
+      //FIXME: actually return supported compression
+      return true;
+    default:
+      return false;
+  }
+#endif
+}
diff --git a/xbmc/guilib/TextureGL.h b/xbmc/guilib/TextureGL.h
index 51c7035de6ced..980770f711ed1 100644
--- a/xbmc/guilib/TextureGL.h
+++ b/xbmc/guilib/TextureGL.h
@@ -25,6 +25,7 @@ class CGLTexture : public CTexture
   void DestroyTextureObject() override;
   void LoadToGPU() override;
   void BindToUnit(unsigned int unit) override;
+  bool IsGPUFormatSupported(const uint32_t format) override;
 
 protected:
   GLuint m_texture = 0;
diff --git a/xbmc/guilib/TextureManager.cpp b/xbmc/guilib/TextureManager.cpp
index ddf2e77e7f99a..d4f51883164c5 100644
--- a/xbmc/guilib/TextureManager.cpp
+++ b/xbmc/guilib/TextureManager.cpp
@@ -297,6 +297,17 @@ const CTextureArray& CGUITextureManager::Load(const std::string& strTextureName,
   if (!HasTexture(strTextureName, &strPath, &bundle, &size))
     return emptyTexture;
 
+  unsigned int textureFormat = XB_FMT_UNKNOWN;
+  if (StringUtils::StartsWith(strTextureName, "special://skin/"))
+  {
+    if (strTextureName.find("_alpha.") != std::string::npos)
+      textureFormat = XB_FMT_A8;
+    else if (strTextureName.find("_luma.") != std::string::npos)
+      textureFormat = XB_FMT_L8;
+    else if (strTextureName.find("_lumaalpha.") != std::string::npos)
+      textureFormat = XB_FMT_L8A8;
+  }
+
   if (size) // we found the texture
   {
     for (int i = 0; i < (int)m_vecTextures.size(); ++i)
@@ -393,10 +404,11 @@ const CTextureArray& CGUITextureManager::Load(const std::string& strTextureName,
     auto frame = anim.ReadFrame();
     while (frame)
     {
-      std::unique_ptr<CTexture> glTexture = CTexture::CreateTexture();
+      std::unique_ptr<CTexture> glTexture = CTexture::CreateTexture(0, 0, textureFormat);
       if (glTexture)
       {
-        glTexture->LoadFromMemory(anim.Width(), anim.Height(), frame->GetPitch(), XB_FMT_A8R8G8B8, true, frame->m_pImage);
+        glTexture->LoadFromMemory(anim.Width(), anim.Height(), frame->GetPitch(), textureFormat,
+                                  true, frame->m_pImage);
         maxWidth = std::max(maxWidth, glTexture->GetWidth());
         maxHeight = std::max(maxHeight, glTexture->GetHeight());
         pMap->Add(std::move(glTexture), frame->m_delay);
@@ -436,7 +448,7 @@ const CTextureArray& CGUITextureManager::Load(const std::string& strTextureName,
   }
   else
   {
-    pTexture = CTexture::LoadFromFile(strPath);
+    pTexture = CTexture::LoadFromFile(strPath, 0, 0, false, "", textureFormat);
     if (!pTexture)
       return emptyTexture;
     width = pTexture->GetWidth();
diff --git a/xbmc/guilib/iimage.h b/xbmc/guilib/iimage.h
index 299e74c6f2b06..7a0c97243d1cc 100644
--- a/xbmc/guilib/iimage.h
+++ b/xbmc/guilib/iimage.h
@@ -8,6 +8,8 @@
 
 #pragma once
 
+#include "guilib/TextureFormats.h"
+
 #include <string>
 
 class IImage
@@ -25,6 +27,17 @@ class IImage
    \return true if the image could be loaded
    */
   virtual bool LoadImageFromMemory(unsigned char* buffer, unsigned int bufSize, unsigned int width, unsigned int height)=0;
+  /*!
+   \brief Check if a Kodi texture format is compatible
+   \param format The format to check
+   \return true if the decoder can write such a texture
+   */
+  virtual bool IsFormatSupported(uint32_t format) { return format == XB_FMT_A8R8G8B8; }
+  /*!
+   \brief Reports to what format the image could be decoded into
+   \return the Kodi texture format closest to the source format
+   */
+  uint32_t GetCompatibleFormat() const { return m_format; }
   /*!
    \brief Decodes the previously loaded image data to the output buffer in 32 bit raw bits
    \param pixels The output buffer
@@ -70,5 +83,5 @@ class IImage
   unsigned int m_originalHeight = 0;  ///< original image height before scaling or cropping
   unsigned int m_orientation = 0;
   bool m_hasAlpha = false;
-
+  uint32_t m_format{XB_FMT_A8R8G8B8};
 };

From b5ea0990018899d4a5534dca0c3ebb7360d15520 Mon Sep 17 00:00:00 2001
From: sarbes <sarbes@kodi.tv>
Date: Thu, 16 Mar 2023 00:56:46 +0100
Subject: [PATCH 4/4] Implement L/A/LA support for the texture packer

---
 .../TexturePacker/src/TexturePacker.cpp       | 127 +++++++++++++++---
 .../TexturePacker/src/decoder/IDecoder.h      |   3 +
 .../TexturePacker/src/decoder/PNGDecoder.cpp  |   3 +
 3 files changed, 116 insertions(+), 17 deletions(-)

diff --git a/tools/depends/native/TexturePacker/src/TexturePacker.cpp b/tools/depends/native/TexturePacker/src/TexturePacker.cpp
index a6fd4284f1e98..4f80b5251fd10 100644
--- a/tools/depends/native/TexturePacker/src/TexturePacker.cpp
+++ b/tools/depends/native/TexturePacker/src/TexturePacker.cpp
@@ -67,6 +67,10 @@ const char *GetFormatString(unsigned int format)
     return "ARGB ";
   case XB_FMT_A8:
     return "A8   ";
+  case XB_FMT_L8:
+    return "L8   ";
+  case XB_FMT_L8A8:
+    return "L8A8 ";
   default:
     return "?????";
   }
@@ -137,7 +141,13 @@ void CreateSkeletonHeader(CXBTFWriter& xbtfWriter, const std::string& fullPath)
   CreateSkeletonHeaderImpl(xbtfWriter, fullPath, temp);
 }
 
-CXBTFFrame appendContent(CXBTFWriter &writer, int width, int height, unsigned char *data, unsigned int size, unsigned int format, bool hasAlpha, unsigned int flags)
+CXBTFFrame appendContent(CXBTFWriter& writer,
+                         int width,
+                         int height,
+                         unsigned char* data,
+                         unsigned int size,
+                         unsigned int format,
+                         unsigned int flags)
 {
   CXBTFFrame frame;
   lzo_uint packedSize = size;
@@ -181,36 +191,23 @@ CXBTFFrame appendContent(CXBTFWriter &writer, int width, int height, unsigned ch
   frame.SetUnpackedSize(size);
   frame.SetWidth(width);
   frame.SetHeight(height);
-  frame.SetFormat(hasAlpha ? format : format | XB_FMT_OPAQUE);
+  frame.SetFormat(format);
   frame.SetDuration(0);
   return frame;
 }
 
-bool HasAlpha(unsigned char *argb, unsigned int width, unsigned int height)
-{
-  unsigned char *p = argb + 3; // offset of alpha
-  for (unsigned int i = 0; i < 4*width*height; i += 4)
-  {
-    if (p[i] != 0xff)
-      return true;
-  }
-  return false;
-}
-
 CXBTFFrame createXBTFFrame(RGBAImage &image, CXBTFWriter& writer, double maxMSE, unsigned int flags)
 {
 
   int width, height;
-  unsigned int format = 0;
   unsigned char* argb = (unsigned char*)image.pixels;
 
   width  = image.width;
   height = image.height;
-  bool hasAlpha = HasAlpha(argb, width, height);
 
   CXBTFFrame frame;
-  format = XB_FMT_A8R8G8B8;
-  frame = appendContent(writer, width, height, argb, (width * height * 4), format, hasAlpha, flags);
+  frame = appendContent(writer, width, height, argb, (width * height * image.bbp / 8), image.format,
+                        flags);
 
   return frame;
 }
@@ -251,6 +248,101 @@ static bool checkDupe(struct MD5Context* ctx,
   return false;
 }
 
+void convertToSingleChannel(RGBAImage& image, uint32_t channel)
+{
+  uint32_t size = (image.width * image.height);
+  for (uint32_t i = 0; i < size; i++)
+  {
+    image.pixels[i] = image.pixels[i * 4 + channel];
+  }
+  if (channel == 3)
+    image.format = XB_FMT_A8;
+  else
+  {
+    image.format = XB_FMT_L8;
+    image.format |= XB_FMT_OPAQUE;
+  }
+  image.bbp = 8;
+  image.pitch = 1 * image.width;
+}
+
+void convertToDualChannel(RGBAImage& image)
+{
+  uint32_t size = (image.width * image.height);
+  for (uint32_t i = 0; i < size; i++)
+  {
+    image.pixels[i * 2] = image.pixels[i * 4];
+    image.pixels[i * 2 + 1] = image.pixels[i * 4 + 3];
+  }
+  image.format = XB_FMT_L8A8;
+  image.bbp = 16;
+  image.pitch = 2 * image.width;
+}
+
+void ReduceChannels(RGBAImage& image)
+{
+  if (image.format != XB_FMT_A8R8G8B8)
+    return;
+  uint32_t size = (image.width * image.height);
+  char red = image.pixels[0];
+  char green = image.pixels[1];
+  char blue = image.pixels[2];
+  char alpha = image.pixels[3];
+  bool uniformRed = true;
+  bool uniformGreen = true;
+  bool uniformBlue = true;
+  bool uniformAlpha = true;
+  bool isGrey = true;
+
+  // Checks each pixel for various properties.
+  for (uint32_t i = 0; i < size; i++)
+  {
+    if (image.pixels[i * 4] != red && image.pixels[i * 4 + 3] != (char)0x00)
+      uniformRed = false;
+    if (image.pixels[i * 4 + 1] != green && image.pixels[i * 4 + 3] != (char)0x00)
+      uniformGreen = false;
+    if (image.pixels[i * 4 + 2] != blue && image.pixels[i * 4 + 3] != (char)0x00)
+      uniformBlue = false;
+    if (image.pixels[i * 4 + 3] != alpha)
+      uniformAlpha = false;
+    if (!(image.pixels[i * 4] == image.pixels[i * 4 + 1] &&
+          image.pixels[i * 4] == image.pixels[i * 4 + 2]) &&
+        image.pixels[i * 4 + 3] != (char)0x00)
+      isGrey = false;
+  }
+
+  if (uniformAlpha && alpha != (char)0xff)
+    printf("WARNING: uniform alpha detected! Use diffusecolor!\n");
+
+  bool isWhite = red == (char)0xff && green == (char)0xff && blue == (char)0xff;
+  if (uniformRed && uniformGreen && uniformBlue && !isWhite)
+    printf("WARNING: uniform color detected! Use diffusecolor!\n");
+
+  if (uniformAlpha && alpha == (char)0xff)
+  {
+    image.format |= XB_FMT_OPAQUE;
+    if (isGrey)
+    {
+      convertToSingleChannel(image, 1);
+      return;
+    }
+    return;
+  }
+  else
+  {
+    if (uniformRed && uniformGreen && uniformBlue && isWhite)
+    {
+      convertToSingleChannel(image, 3);
+      return;
+    }
+    else if (isGrey)
+    {
+      convertToDualChannel(image);
+      return;
+    }
+  }
+}
+
 int createBundle(const std::string& InputDir, const std::string& OutputFile, double maxMSE, unsigned int flags, bool dupecheck)
 {
   CXBTFWriter writer(OutputFile);
@@ -318,6 +410,7 @@ int createBundle(const std::string& InputDir, const std::string& OutputFile, dou
     {
       for (unsigned int j = 0; j < frames.frameList.size(); j++)
       {
+        ReduceChannels(frames.frameList[j].rgbaImage);
         printf("    frame %4i (delay:%4i)                         ", j, frames.frameList[j].delay);
         CXBTFFrame frame = createXBTFFrame(frames.frameList[j].rgbaImage, writer, maxMSE, flags);
         frame.SetDuration(frames.frameList[j].delay);
diff --git a/tools/depends/native/TexturePacker/src/decoder/IDecoder.h b/tools/depends/native/TexturePacker/src/decoder/IDecoder.h
index c9ac346514f18..f1ca2a9611a03 100644
--- a/tools/depends/native/TexturePacker/src/decoder/IDecoder.h
+++ b/tools/depends/native/TexturePacker/src/decoder/IDecoder.h
@@ -20,6 +20,8 @@
 
 #pragma once
 
+#include "guilib/TextureFormats.h"
+
 #include <cstdint>
 #include <string>
 #include <vector>
@@ -61,6 +63,7 @@ class RGBAImage
   int height = 0; // height
   int bbp = 0; // bits per pixel
   int pitch = 0; // rowsize in bytes
+  uint32_t format{XB_FMT_A8R8G8B8};
 };
 
 class DecodedFrame
diff --git a/tools/depends/native/TexturePacker/src/decoder/PNGDecoder.cpp b/tools/depends/native/TexturePacker/src/decoder/PNGDecoder.cpp
index f327400f6b9d3..e2cfe51ac6531 100644
--- a/tools/depends/native/TexturePacker/src/decoder/PNGDecoder.cpp
+++ b/tools/depends/native/TexturePacker/src/decoder/PNGDecoder.cpp
@@ -178,6 +178,9 @@ bool PNGDecoder::LoadFile(const std::string &filename, DecodedFrames &frames)
     png_set_gray_to_rgb(png_ptr);
   }
 
+  if (color_type == PNG_COLOR_TYPE_PALETTE)
+    printf("WARNING: Palette texture might not decode to optimally, please avoid!\n");
+
   // Update the png info struct.
   png_read_update_info(png_ptr, info_ptr);
 
